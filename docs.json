[{"name":"Action","comment":" This module lets you organize your update function for different states.\r\n\r\nThere is a quick guideline to follow if you want to use this module:\r\n\r\n1.  Add a type alias. For example:\r\n\r\n         type alias UserAction =\r\n             Action\r\n                 Never --Allow Updates?\r\n                 Never --Allow Cmd other then Cmd.none?\r\n                 Never --Allow Transitions?\r\n                 Never --Allow Exit?\r\n\r\n2.  Start by setting the first `Never` to your `stateModel`:\r\n\r\n         type alias UserAction =\r\n             Action\r\n                 UserModel -- updates allowed.\r\n                 Never --Allow Cmd other then Cmd.none? If Yes use UserMsg\r\n                 Never --Allow Transitions?\r\n                 Never --Allow Exit?\r\n\r\n3.  Write your update function. In our very basic example, it look like this:\r\n\r\n         update : Msg -> Model -> (Model, Cmd Msg)\r\n         update msg model =\r\n             case msg of\r\n                 (UserSpecific userMsg,User userModel) ->\r\n                     updateUser userMsg userModel\r\n                     |> Action.config\r\n                     |> Action.withUpdate User never\r\n                     --If you want to allow Cmd you would use the following line\r\n                     --|> Action.withUpdate User UserSpecific\r\n                     |> Action.apply\r\n\r\n                 _ ->\r\n                     (model,Cmd.none)\r\n\r\n4.  Extend if needed.\r\n\r\n\r\n# Actions\r\n\r\n@docs Action, updating, transitioning, exiting\r\n\r\n\r\n# Config Pipeline\r\n\r\n@docs config, apply, withUpdate, withTransition, withExit\r\n\r\n","unions":[{"name":"Action","comment":" An `Action` specifies the behaviour of an update function.\r\nA Action can either be\r\n\r\n  - `Update (model,Cmd msg)` - Updates the model as usual.\r\n  - `Transition transitionData` - Transitions to a different model using `data` (like logging in)\r\n  - `Exit` - Transitions to a different model with less access (like logging out)\r\n\r\nA Action has 4 type parameters: `model`,`msg`,`transitionData` and `exitAllowed`.\r\n\r\n  - The type of `exitAllowed` should be set to `()`. However,\r\n  - If you want to forbid `Exit`, then set `exitAllowed` to `Never`.\r\n  - If you want to forbid `Update (model,Cmd msg)`, then set `model` to `Never`.\r\n  - If you want to forbid `Cmd msg` other then `Cmd.none`, then set `msg` to `Never`.\r\n  - If you want to forbid `Transition transitionData`, then set `transitionData` to `Never`.\r\n\r\n","args":["model","msg","transitionData","exitAllowed"],"cases":[]}],"aliases":[],"values":[{"name":"apply","comment":" Ends the Configuration and returns a `(Model, Cmd Msg)`.\r\n","type":"Action.ActionConfig stateModel stateMsg transitionData exitAllowed { exitFun : exitAllowed -> ( model, Platform.Cmd.Cmd msg ), modelMapper : stateModel -> model, msgMapper : stateMsg -> msg, transitionFun : transitionData -> ( model, Platform.Cmd.Cmd msg ) } -> ( model, Platform.Cmd.Cmd msg )"},{"name":"config","comment":" Starts the configuration of the Action.\r\n\r\nThe most basic config pipeline looks like this:\r\n\r\n    updateFunction\r\n        |> Action.config\r\n        |> Action.apply\r\n\r\nwith `updateFunction : Model -> Msg -> Action Model Msg TransitionData ExitAllowed`.\r\n\r\nYou will need to add `withExit`,`withUpdate` and or `withTransition` to make\r\nthe code compile.\r\n\r\n","type":"Action.Action stateModel stateMsg transitionData exitAllowed -> Action.ActionConfig stateModel stateMsg transitionData exitAllowed (Action.Config (Basics.Never -> ( model, Platform.Cmd.Cmd msg )) (Basics.Never -> model) (Basics.Never -> msg) (Basics.Never -> ( model, Platform.Cmd.Cmd msg )))"},{"name":"exiting","comment":" Transitions to a different model with less access. (like logging out)\r\n\r\n    import Task\r\n\r\n    exiting\r\n    |> Action.config\r\n    |> Action.withExit ((42,0),Cmd.none)\r\n    |> Action.apply\r\n    |> Tuple.first\r\n    --> (42,0)\r\n\r\nChecklist in case of errors:\r\n\r\n  - `exitAllowed` should be `()`\r\n  - the config pipeline should include `withExit`\r\n\r\n","type":"Action.Action stateModel stateMsg transitionData ()"},{"name":"transitioning","comment":" Transitions to a different model.\r\n\r\n    import Task\r\n\r\n    transitioning 42\r\n    |> Action.config\r\n    |> Action.withTransition (\\int -> ((int,0),Cmd.none))\r\n    |> Action.apply\r\n    |> Tuple.first\r\n    --> (42,0)\r\n\r\nChecklist in case of errors:\r\n\r\n  - `transitionData` should not be `Never`\r\n  - the config pipeline should include `withTransition`\r\n\r\n","type":"transitionData -> Action.Action stateModel stateMsg transitionData exitAllowed"},{"name":"updating","comment":" Updates the model as usual.\r\n\r\n    import Task\r\n\r\n    updating (42, Cmd.none)\r\n    |> Action.config\r\n    |> Action.withUpdate (\\int -> (int,0)) never\r\n    |> Action.apply\r\n    |> Tuple.first\r\n    --> (42,0)\r\n\r\nChecklist in case of errors:\r\n\r\n  - `stateModel` should not be `Never`\r\n  - the config pipeline should include `withUpdate`\r\n\r\n","type":"( stateModel, Platform.Cmd.Cmd stateMsg ) -> Action.Action stateModel stateMsg transitionData exitAllowed"},{"name":"withExit","comment":" Specifies the state the resulting `(model, Cmd msg)` when exiting.\r\n\r\nFor a hard exit you can use\r\n\r\n    withExit (init ())\r\n\r\nChecklist in case of errors:\r\n\r\n  - `exitAllowed` should be `()`\r\n  - the config pipeline should include `withExit`\r\n\r\n","type":"( model, Platform.Cmd.Cmd msg ) -> Action.ActionConfig stateModel stateMsg transitionData () (Action.Config (Basics.Never -> ( model, Platform.Cmd.Cmd msg )) b c d) -> Action.ActionConfig stateModel stateMsg transitionData () (Action.Config (() -> ( model, Platform.Cmd.Cmd msg )) b c d)"},{"name":"withTransition","comment":" Specifies how the state transitions to another state.\r\n\r\nLets say we want a user to login.\r\n\r\n    type alias User =\r\n        { name : String\r\n        , admin : Bool\r\n        }\r\n\r\n    initUser : String -> User\r\n    initUser string =\r\n        { name = string\r\n        , admin = string == \"Admin\"\r\n        }\r\n\r\n    type Model\r\n        = Maybe User\r\n\r\nThen we can use `withTransition \\string -> (Just <| initUser string, Cmd.none)`\r\nfor logging in a user.\r\n\r\nChecklist in case of errors:\r\n\r\n  - `transitionData` should not be `Never`\r\n  - the config pipeline should include `withTransition`\r\n\r\n","type":"(transitionData -> ( model, Platform.Cmd.Cmd msg )) -> Action.ActionConfig stateModel stateMsg transitionData2 exitAllowed (Action.Config a b c d) -> Action.ActionConfig stateModel stateMsg transitionData2 exitAllowed (Action.Config a b c (transitionData -> ( model, Platform.Cmd.Cmd msg )))"},{"name":"withUpdate","comment":" Specifies how the `stateModel`/`stateMsg` is embedded in the main `model`/`msg`.\r\n\r\nLets say we have a password protected area:\r\n\r\n    type Model\r\n        = Maybe RestrictedModel\r\n\r\n    type Msg\r\n        = GuestSpecific GuestMsg\r\n        | RestrictedSpecific RestrictedMsg\r\n\r\nThen we would use `withUpdate Just RestrictedSpecific` for the restricted area and\r\n`withUpdate (always Nothing) GuestSpecific` for the guest area.\r\n\r\nChecklist in case of errors:\r\n\r\n  - `stateModel` should not be `Never`\r\n  - the config pipeline should include `withUpdate`\r\n\r\n","type":"(stateModel -> model) -> (stateMsg -> msg) -> Action.ActionConfig stateModel2 stateMsg transitionData exitAllowed (Action.Config a b c d) -> Action.ActionConfig stateModel2 stateMsg transitionData exitAllowed (Action.Config a (stateModel -> model) (stateMsg -> msg) d)"}],"binops":[]}]